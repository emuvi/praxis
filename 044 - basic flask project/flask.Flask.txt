Help on class Flask in flask:

flask.Flask = class Flask(flask.scaffold.Scaffold)
 |  flask.Flask(import_name: 'str', static_url_path: 'str | None' = None, static_folder: 'str | os.PathLike | None' = 'static', static_host: 'str | None' = None, host_matching: 'bool' = False, subdomain_matching: 'bool' = False, template_folder: 'str | os.PathLike | None' = 'templates', instance_path: 'str | None' = None, instance_relative_config: 'bool' = False, root_path: 'str | None' = None)
 |  
 |  The flask object implements a WSGI application and acts as the central
 |  object.  It is passed the name of the module or package of the
 |  application.  Once it is created it will act as a central registry for
 |  the view functions, the URL rules, template configuration and much more.
 |  
 |  The name of the package is used to resolve resources from inside the
 |  package or the folder the module is contained in depending on if the
 |  package parameter resolves to an actual python package (a folder with
 |  an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).
 |  
 |  For more information about resource loading, see :func:`open_resource`.
 |  
 |  Usually you create a :class:`Flask` instance in your main module or
 |  in the :file:`__init__.py` file of your package like this::
 |  
 |      from flask import Flask
 |      app = Flask(__name__)
 |  
 |  .. admonition:: About the First Parameter
 |  
 |      The idea of the first parameter is to give Flask an idea of what
 |      belongs to your application.  This name is used to find resources
 |      on the filesystem, can be used by extensions to improve debugging
 |      information and a lot more.
 |  
 |      So it's important what you provide there.  If you are using a single
 |      module, `__name__` is always the correct value.  If you however are
 |      using a package, it's usually recommended to hardcode the name of
 |      your package there.
 |  
 |      For example if your application is defined in :file:`yourapplication/app.py`
 |      you should create it with one of the two versions below::
 |  
 |          app = Flask('yourapplication')
 |          app = Flask(__name__.split('.')[0])
 |  
 |      Why is that?  The application will work even with `__name__`, thanks
 |      to how resources are looked up.  However it will make debugging more
 |      painful.  Certain extensions can make assumptions based on the
 |      import name of your application.  For example the Flask-SQLAlchemy
 |      extension will look for the code in your application that triggered
 |      an SQL query in debug mode.  If the import name is not properly set
 |      up, that debugging information is lost.  (For example it would only
 |      pick up SQL queries in `yourapplication.app` and not
 |      `yourapplication.views.frontend`)
 |  
 |  .. versionadded:: 0.7
 |     The `static_url_path`, `static_folder`, and `template_folder`
 |     parameters were added.
 |  
 |  .. versionadded:: 0.8
 |     The `instance_path` and `instance_relative_config` parameters were
 |     added.
 |  
 |  .. versionadded:: 0.11
 |     The `root_path` parameter was added.
 |  
 |  .. versionadded:: 1.0
 |     The ``host_matching`` and ``static_host`` parameters were added.
 |  
 |  .. versionadded:: 1.0
 |     The ``subdomain_matching`` parameter was added. Subdomain
 |     matching needs to be enabled manually now. Setting
 |     :data:`SERVER_NAME` does not implicitly enable it.
 |  
 |  :param import_name: the name of the application package
 |  :param static_url_path: can be used to specify a different path for the
 |                          static files on the web.  Defaults to the name
 |                          of the `static_folder` folder.
 |  :param static_folder: The folder with static files that is served at
 |      ``static_url_path``. Relative to the application ``root_path``
 |      or an absolute path. Defaults to ``'static'``.
 |  :param static_host: the host to use when adding the static route.
 |      Defaults to None. Required when using ``host_matching=True``
 |      with a ``static_folder`` configured.
 |  :param host_matching: set ``url_map.host_matching`` attribute.
 |      Defaults to False.
 |  :param subdomain_matching: consider the subdomain relative to
 |      :data:`SERVER_NAME` when matching routes. Defaults to False.
 |  :param template_folder: the folder that contains the templates that should
 |                          be used by the application.  Defaults to
 |                          ``'templates'`` folder in the root path of the
 |                          application.
 |  :param instance_path: An alternative instance path for the application.
 |                        By default the folder ``'instance'`` next to the
 |                        package or module is assumed to be the instance
 |                        path.
 |  :param instance_relative_config: if set to ``True`` relative filenames
 |                                   for loading the config are assumed to
 |                                   be relative to the instance path instead
 |                                   of the application root.
 |  :param root_path: The path to the root of the application files.
 |      This should only be set manually when it can't be detected
 |      automatically, such as for namespace packages.
 |  
 |  Method resolution order:
 |      Flask
 |      flask.scaffold.Scaffold
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __call__(self, environ: 'dict', start_response: 't.Callable') -> 't.Any'
 |      The WSGI server calls the Flask application object as the
 |      WSGI application. This calls :meth:`wsgi_app`, which can be
 |      wrapped to apply middleware.
 |  
 |  __init__(self, import_name: 'str', static_url_path: 'str | None' = None, static_folder: 'str | os.PathLike | None' = 'static', static_host: 'str | None' = None, host_matching: 'bool' = False, subdomain_matching: 'bool' = False, template_folder: 'str | os.PathLike | None' = 'templates', instance_path: 'str | None' = None, instance_relative_config: 'bool' = False, root_path: 'str | None' = None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  add_template_filter(self, f: 'ft.TemplateFilterCallable', name: 'str | None' = None) -> 'None'
 |      Register a custom template filter.  Works exactly like the
 |      :meth:`template_filter` decorator.
 |      
 |      :param name: the optional name of the filter, otherwise the
 |                   function name will be used.
 |  
 |  add_template_global(self, f: 'ft.TemplateGlobalCallable', name: 'str | None' = None) -> 'None'
 |      Register a custom template global function. Works exactly like the
 |      :meth:`template_global` decorator.
 |      
 |      .. versionadded:: 0.10
 |      
 |      :param name: the optional name of the global function, otherwise the
 |                   function name will be used.
 |  
 |  add_template_test(self, f: 'ft.TemplateTestCallable', name: 'str | None' = None) -> 'None'
 |      Register a custom template test.  Works exactly like the
 |      :meth:`template_test` decorator.
 |      
 |      .. versionadded:: 0.10
 |      
 |      :param name: the optional name of the test, otherwise the
 |                   function name will be used.
 |  
 |  add_url_rule(self, rule: 'str', endpoint: 'str | None' = None, view_func: 'ft.RouteCallable | None' = None, provide_automatic_options: 'bool | None' = None, **options: 't.Any') -> 'None'
 |      Register a rule for routing incoming requests and building
 |      URLs. The :meth:`route` decorator is a shortcut to call this
 |      with the ``view_func`` argument. These are equivalent:
 |      
 |      .. code-block:: python
 |      
 |          @app.route("/")
 |          def index():
 |              ...
 |      
 |      .. code-block:: python
 |      
 |          def index():
 |              ...
 |      
 |          app.add_url_rule("/", view_func=index)
 |      
 |      See :ref:`url-route-registrations`.
 |      
 |      The endpoint name for the route defaults to the name of the view
 |      function if the ``endpoint`` parameter isn't passed. An error
 |      will be raised if a function has already been registered for the
 |      endpoint.
 |      
 |      The ``methods`` parameter defaults to ``["GET"]``. ``HEAD`` is
 |      always added automatically, and ``OPTIONS`` is added
 |      automatically by default.
 |      
 |      ``view_func`` does not necessarily need to be passed, but if the
 |      rule should participate in routing an endpoint name must be
 |      associated with a view function at some point with the
 |      :meth:`endpoint` decorator.
 |      
 |      .. code-block:: python
 |      
 |          app.add_url_rule("/", endpoint="index")
 |      
 |          @app.endpoint("index")
 |          def index():
 |              ...
 |      
 |      If ``view_func`` has a ``required_methods`` attribute, those
 |      methods are added to the passed and automatic methods. If it
 |      has a ``provide_automatic_methods`` attribute, it is used as the
 |      default if the parameter is not passed.
 |      
 |      :param rule: The URL rule string.
 |      :param endpoint: The endpoint name to associate with the rule
 |          and view function. Used when routing and building URLs.
 |          Defaults to ``view_func.__name__``.
 |      :param view_func: The view function to associate with the
 |          endpoint name.
 |      :param provide_automatic_options: Add the ``OPTIONS`` method and
 |          respond to ``OPTIONS`` requests automatically.
 |      :param options: Extra options passed to the
 |          :class:`~werkzeug.routing.Rule` object.
 |  
 |  app_context(self) -> 'AppContext'
 |      Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
 |      block to push the context, which will make :data:`current_app`
 |      point at this application.
 |      
 |      An application context is automatically pushed by
 |      :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`
 |      when handling a request, and when running a CLI command. Use
 |      this to manually create a context outside of these situations.
 |      
 |      ::
 |      
 |          with app.app_context():
 |              init_db()
 |      
 |      See :doc:`/appcontext`.
 |      
 |      .. versionadded:: 0.9
 |  
 |  async_to_sync(self, func: 't.Callable[..., t.Coroutine]') -> 't.Callable[..., t.Any]'
 |      Return a sync function that will run the coroutine function.
 |      
 |      .. code-block:: python
 |      
 |          result = app.async_to_sync(func)(*args, **kwargs)
 |      
 |      Override this method to change how the app converts async code
 |      to be synchronously callable.
 |      
 |      .. versionadded:: 2.0
 |  
 |  auto_find_instance_path(self) -> 'str'
 |      Tries to locate the instance path if it was not provided to the
 |      constructor of the application class.  It will basically calculate
 |      the path to a folder named ``instance`` next to your main file or
 |      the package.
 |      
 |      .. versionadded:: 0.8
 |  
 |  create_global_jinja_loader(self) -> 'DispatchingJinjaLoader'
 |      Creates the loader for the Jinja2 environment.  Can be used to
 |      override just the loader and keeping the rest unchanged.  It's
 |      discouraged to override this function.  Instead one should override
 |      the :meth:`jinja_loader` function instead.
 |      
 |      The global loader dispatches between the loaders of the application
 |      and the individual blueprints.
 |      
 |      .. versionadded:: 0.7
 |  
 |  create_jinja_environment(self) -> 'Environment'
 |      Create the Jinja environment based on :attr:`jinja_options`
 |      and the various Jinja-related methods of the app. Changing
 |      :attr:`jinja_options` after this will have no effect. Also adds
 |      Flask-related globals and filters to the environment.
 |      
 |      .. versionchanged:: 0.11
 |         ``Environment.auto_reload`` set in accordance with
 |         ``TEMPLATES_AUTO_RELOAD`` configuration option.
 |      
 |      .. versionadded:: 0.5
 |  
 |  create_url_adapter(self, request: 'Request | None') -> 'MapAdapter | None'
 |      Creates a URL adapter for the given request. The URL adapter
 |      is created at a point where the request context is not yet set
 |      up so the request is passed explicitly.
 |      
 |      .. versionadded:: 0.6
 |      
 |      .. versionchanged:: 0.9
 |         This can now also be called without a request object when the
 |         URL adapter is created for the application context.
 |      
 |      .. versionchanged:: 1.0
 |          :data:`SERVER_NAME` no longer implicitly enables subdomain
 |          matching. Use :attr:`subdomain_matching` instead.
 |  
 |  dispatch_request(self) -> 'ft.ResponseReturnValue'
 |      Does the request dispatching.  Matches the URL and returns the
 |      return value of the view or error handler.  This does not have to
 |      be a response object.  In order to convert the return value to a
 |      proper response object, call :func:`make_response`.
 |      
 |      .. versionchanged:: 0.7
 |         This no longer does the exception handling, this code was
 |         moved to the new :meth:`full_dispatch_request`.
 |  
 |  do_teardown_appcontext(self, exc: 'BaseException | None' = <object object at 0x0000021D759F5350>) -> 'None'
 |      Called right before the application context is popped.
 |      
 |      When handling a request, the application context is popped
 |      after the request context. See :meth:`do_teardown_request`.
 |      
 |      This calls all functions decorated with
 |      :meth:`teardown_appcontext`. Then the
 |      :data:`appcontext_tearing_down` signal is sent.
 |      
 |      This is called by
 |      :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.
 |      
 |      .. versionadded:: 0.9
 |  
 |  do_teardown_request(self, exc: 'BaseException | None' = <object object at 0x0000021D759F5350>) -> 'None'
 |      Called after the request is dispatched and the response is
 |      returned, right before the request context is popped.
 |      
 |      This calls all functions decorated with
 |      :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`
 |      if a blueprint handled the request. Finally, the
 |      :data:`request_tearing_down` signal is sent.
 |      
 |      This is called by
 |      :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,
 |      which may be delayed during testing to maintain access to
 |      resources.
 |      
 |      :param exc: An unhandled exception raised while dispatching the
 |          request. Detected from the current exception information if
 |          not passed. Passed to each teardown function.
 |      
 |      .. versionchanged:: 0.9
 |          Added the ``exc`` argument.
 |  
 |  ensure_sync(self, func: 't.Callable') -> 't.Callable'
 |      Ensure that the function is synchronous for WSGI workers.
 |      Plain ``def`` functions are returned as-is. ``async def``
 |      functions are wrapped to run and wait for the response.
 |      
 |      Override this method to change how the app runs async views.
 |      
 |      .. versionadded:: 2.0
 |  
 |  finalize_request(self, rv: 'ft.ResponseReturnValue | HTTPException', from_error_handler: 'bool' = False) -> 'Response'
 |      Given the return value from a view function this finalizes
 |      the request by converting it into a response and invoking the
 |      postprocessing functions.  This is invoked for both normal
 |      request dispatching as well as error handlers.
 |      
 |      Because this means that it might be called as a result of a
 |      failure a special safe mode is available which can be enabled
 |      with the `from_error_handler` flag.  If enabled, failures in
 |      response processing will be logged and otherwise ignored.
 |      
 |      :internal:
 |  
 |  full_dispatch_request(self) -> 'Response'
 |      Dispatches the request and on top of that performs request
 |      pre and postprocessing as well as HTTP exception catching and
 |      error handling.
 |      
 |      .. versionadded:: 0.7
 |  
 |  handle_exception(self, e: 'Exception') -> 'Response'
 |      Handle an exception that did not have an error handler
 |      associated with it, or that was raised from an error handler.
 |      This always causes a 500 ``InternalServerError``.
 |      
 |      Always sends the :data:`got_request_exception` signal.
 |      
 |      If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug
 |      mode, the error will be re-raised so that the debugger can
 |      display it. Otherwise, the original exception is logged, and
 |      an :exc:`~werkzeug.exceptions.InternalServerError` is returned.
 |      
 |      If an error handler is registered for ``InternalServerError`` or
 |      ``500``, it will be used. For consistency, the handler will
 |      always receive the ``InternalServerError``. The original
 |      unhandled exception is available as ``e.original_exception``.
 |      
 |      .. versionchanged:: 1.1.0
 |          Always passes the ``InternalServerError`` instance to the
 |          handler, setting ``original_exception`` to the unhandled
 |          error.
 |      
 |      .. versionchanged:: 1.1.0
 |          ``after_request`` functions and other finalization is done
 |          even for the default 500 response when there is no handler.
 |      
 |      .. versionadded:: 0.3
 |  
 |  handle_http_exception(self, e: 'HTTPException') -> 'HTTPException | ft.ResponseReturnValue'
 |      Handles an HTTP exception.  By default this will invoke the
 |      registered error handlers and fall back to returning the
 |      exception as response.
 |      
 |      .. versionchanged:: 1.0.3
 |          ``RoutingException``, used internally for actions such as
 |           slash redirects during routing, is not passed to error
 |           handlers.
 |      
 |      .. versionchanged:: 1.0
 |          Exceptions are looked up by code *and* by MRO, so
 |          ``HTTPException`` subclasses can be handled with a catch-all
 |          handler for the base ``HTTPException``.
 |      
 |      .. versionadded:: 0.3
 |  
 |  handle_url_build_error(self, error: 'BuildError', endpoint: 'str', values: 'dict[str, t.Any]') -> 'str'
 |      Called by :meth:`.url_for` if a
 |      :exc:`~werkzeug.routing.BuildError` was raised. If this returns
 |      a value, it will be returned by ``url_for``, otherwise the error
 |      will be re-raised.
 |      
 |      Each function in :attr:`url_build_error_handlers` is called with
 |      ``error``, ``endpoint`` and ``values``. If a function returns
 |      ``None`` or raises a ``BuildError``, it is skipped. Otherwise,
 |      its return value is returned by ``url_for``.
 |      
 |      :param error: The active ``BuildError`` being handled.
 |      :param endpoint: The endpoint being built.
 |      :param values: The keyword arguments passed to ``url_for``.
 |  
 |  handle_user_exception(self, e: 'Exception') -> 'HTTPException | ft.ResponseReturnValue'
 |      This method is called whenever an exception occurs that
 |      should be handled. A special case is :class:`~werkzeug
 |      .exceptions.HTTPException` which is forwarded to the
 |      :meth:`handle_http_exception` method. This function will either
 |      return a response value or reraise the exception with the same
 |      traceback.
 |      
 |      .. versionchanged:: 1.0
 |          Key errors raised from request data like ``form`` show the
 |          bad key in debug mode rather than a generic bad request
 |          message.
 |      
 |      .. versionadded:: 0.7
 |  
 |  inject_url_defaults(self, endpoint: 'str', values: 'dict') -> 'None'
 |      Injects the URL defaults for the given endpoint directly into
 |      the values dictionary passed.  This is used internally and
 |      automatically called on URL building.
 |      
 |      .. versionadded:: 0.7
 |  
 |  iter_blueprints(self) -> 't.ValuesView[Blueprint]'
 |      Iterates over all blueprints by the order they were registered.
 |      
 |      .. versionadded:: 0.11
 |  
 |  log_exception(self, exc_info: 'tuple[type, BaseException, TracebackType] | tuple[None, None, None]') -> 'None'
 |      Logs an exception.  This is called by :meth:`handle_exception`
 |      if debugging is disabled and right before the handler is called.
 |      The default implementation logs the exception as error on the
 |      :attr:`logger`.
 |      
 |      .. versionadded:: 0.8
 |  
 |  make_aborter(self) -> 'Aborter'
 |      Create the object to assign to :attr:`aborter`. That object
 |      is called by :func:`flask.abort` to raise HTTP errors, and can
 |      be called directly as well.
 |      
 |      By default, this creates an instance of :attr:`aborter_class`,
 |      which defaults to :class:`werkzeug.exceptions.Aborter`.
 |      
 |      .. versionadded:: 2.2
 |  
 |  make_config(self, instance_relative: 'bool' = False) -> 'Config'
 |      Used to create the config attribute by the Flask constructor.
 |      The `instance_relative` parameter is passed in from the constructor
 |      of Flask (there named `instance_relative_config`) and indicates if
 |      the config should be relative to the instance path or the root path
 |      of the application.
 |      
 |      .. versionadded:: 0.8
 |  
 |  make_default_options_response(self) -> 'Response'
 |      This method is called to create the default ``OPTIONS`` response.
 |      This can be changed through subclassing to change the default
 |      behavior of ``OPTIONS`` responses.
 |      
 |      .. versionadded:: 0.7
 |  
 |  make_response(self, rv: 'ft.ResponseReturnValue') -> 'Response'
 |      Convert the return value from a view function to an instance of
 |      :attr:`response_class`.
 |      
 |      :param rv: the return value from the view function. The view function
 |          must return a response. Returning ``None``, or the view ending
 |          without returning, is not allowed. The following types are allowed
 |          for ``view_rv``:
 |      
 |          ``str``
 |              A response object is created with the string encoded to UTF-8
 |              as the body.
 |      
 |          ``bytes``
 |              A response object is created with the bytes as the body.
 |      
 |          ``dict``
 |              A dictionary that will be jsonify'd before being returned.
 |      
 |          ``list``
 |              A list that will be jsonify'd before being returned.
 |      
 |          ``generator`` or ``iterator``
 |              A generator that returns ``str`` or ``bytes`` to be
 |              streamed as the response.
 |      
 |          ``tuple``
 |              Either ``(body, status, headers)``, ``(body, status)``, or
 |              ``(body, headers)``, where ``body`` is any of the other types
 |              allowed here, ``status`` is a string or an integer, and
 |              ``headers`` is a dictionary or a list of ``(key, value)``
 |              tuples. If ``body`` is a :attr:`response_class` instance,
 |              ``status`` overwrites the exiting value and ``headers`` are
 |              extended.
 |      
 |          :attr:`response_class`
 |              The object is returned unchanged.
 |      
 |          other :class:`~werkzeug.wrappers.Response` class
 |              The object is coerced to :attr:`response_class`.
 |      
 |          :func:`callable`
 |              The function is called as a WSGI application. The result is
 |              used to create a response object.
 |      
 |      .. versionchanged:: 2.2
 |          A generator will be converted to a streaming response.
 |          A list will be converted to a JSON response.
 |      
 |      .. versionchanged:: 1.1
 |          A dict will be converted to a JSON response.
 |      
 |      .. versionchanged:: 0.9
 |         Previously a tuple was interpreted as the arguments for the
 |         response object.
 |  
 |  make_shell_context(self) -> 'dict'
 |      Returns the shell context for an interactive shell for this
 |      application.  This runs all the registered shell context
 |      processors.
 |      
 |      .. versionadded:: 0.11
 |  
 |  open_instance_resource(self, resource: 'str', mode: 'str' = 'rb') -> 't.IO[t.AnyStr]'
 |      Opens a resource from the application's instance folder
 |      (:attr:`instance_path`).  Otherwise works like
 |      :meth:`open_resource`.  Instance resources can also be opened for
 |      writing.
 |      
 |      :param resource: the name of the resource.  To access resources within
 |                       subfolders use forward slashes as separator.
 |      :param mode: resource file opening mode, default is 'rb'.
 |  
 |  preprocess_request(self) -> 'ft.ResponseReturnValue | None'
 |      Called before the request is dispatched. Calls
 |      :attr:`url_value_preprocessors` registered with the app and the
 |      current blueprint (if any). Then calls :attr:`before_request_funcs`
 |      registered with the app and the blueprint.
 |      
 |      If any :meth:`before_request` handler returns a non-None value, the
 |      value is handled as if it was the return value from the view, and
 |      further request handling is stopped.
 |  
 |  process_response(self, response: 'Response') -> 'Response'
 |      Can be overridden in order to modify the response object
 |      before it's sent to the WSGI server.  By default this will
 |      call all the :meth:`after_request` decorated functions.
 |      
 |      .. versionchanged:: 0.5
 |         As of Flask 0.5 the functions registered for after request
 |         execution are called in reverse order of registration.
 |      
 |      :param response: a :attr:`response_class` object.
 |      :return: a new response object or the same, has to be an
 |               instance of :attr:`response_class`.
 |  
 |  raise_routing_exception(self, request: 'Request') -> 't.NoReturn'
 |      Intercept routing exceptions and possibly do something else.
 |      
 |      In debug mode, intercept a routing redirect and replace it with
 |      an error if the body will be discarded.
 |      
 |      With modern Werkzeug this shouldn't occur, since it now uses a
 |      308 status which tells the browser to resend the method and
 |      body.
 |      
 |      .. versionchanged:: 2.1
 |          Don't intercept 307 and 308 redirects.
 |      
 |      :meta private:
 |      :internal:
 |  
 |  redirect(self, location: 'str', code: 'int' = 302) -> 'BaseResponse'
 |      Create a redirect response object.
 |      
 |      This is called by :func:`flask.redirect`, and can be called
 |      directly as well.
 |      
 |      :param location: The URL to redirect to.
 |      :param code: The status code for the redirect.
 |      
 |      .. versionadded:: 2.2
 |          Moved from ``flask.redirect``, which calls this method.
 |  
 |  register_blueprint(self, blueprint: 'Blueprint', **options: 't.Any') -> 'None'
 |      Register a :class:`~flask.Blueprint` on the application. Keyword
 |      arguments passed to this method will override the defaults set on the
 |      blueprint.
 |      
 |      Calls the blueprint's :meth:`~flask.Blueprint.register` method after
 |      recording the blueprint in the application's :attr:`blueprints`.
 |      
 |      :param blueprint: The blueprint to register.
 |      :param url_prefix: Blueprint routes will be prefixed with this.
 |      :param subdomain: Blueprint routes will match on this subdomain.
 |      :param url_defaults: Blueprint routes will use these default values for
 |          view arguments.
 |      :param options: Additional keyword arguments are passed to
 |          :class:`~flask.blueprints.BlueprintSetupState`. They can be
 |          accessed in :meth:`~flask.Blueprint.record` callbacks.
 |      
 |      .. versionchanged:: 2.0.1
 |          The ``name`` option can be used to change the (pre-dotted)
 |          name the blueprint is registered with. This allows the same
 |          blueprint to be registered multiple times with unique names
 |          for ``url_for``.
 |      
 |      .. versionadded:: 0.7
 |  
 |  request_context(self, environ: 'dict') -> 'RequestContext'
 |      Create a :class:`~flask.ctx.RequestContext` representing a
 |      WSGI environment. Use a ``with`` block to push the context,
 |      which will make :data:`request` point at this request.
 |      
 |      See :doc:`/reqcontext`.
 |      
 |      Typically you should not call this from your own code. A request
 |      context is automatically pushed by the :meth:`wsgi_app` when
 |      handling a request. Use :meth:`test_request_context` to create
 |      an environment and context instead of this method.
 |      
 |      :param environ: a WSGI environment
 |  
 |  run(self, host: 'str | None' = None, port: 'int | None' = None, debug: 'bool | None' = None, load_dotenv: 'bool' = True, **options: 't.Any') -> 'None'
 |      Runs the application on a local development server.
 |      
 |      Do not use ``run()`` in a production setting. It is not intended to
 |      meet security and performance requirements for a production server.
 |      Instead, see :doc:`/deploying/index` for WSGI server recommendations.
 |      
 |      If the :attr:`debug` flag is set the server will automatically reload
 |      for code changes and show a debugger in case an exception happened.
 |      
 |      If you want to run the application in debug mode, but disable the
 |      code execution on the interactive debugger, you can pass
 |      ``use_evalex=False`` as parameter.  This will keep the debugger's
 |      traceback screen active, but disable code execution.
 |      
 |      It is not recommended to use this function for development with
 |      automatic reloading as this is badly supported.  Instead you should
 |      be using the :command:`flask` command line script's ``run`` support.
 |      
 |      .. admonition:: Keep in Mind
 |      
 |         Flask will suppress any server error with a generic error page
 |         unless it is in debug mode.  As such to enable just the
 |         interactive debugger without the code reloading, you have to
 |         invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.
 |         Setting ``use_debugger`` to ``True`` without being in debug mode
 |         won't catch any exceptions because there won't be any to
 |         catch.
 |      
 |      :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
 |          have the server available externally as well. Defaults to
 |          ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable
 |          if present.
 |      :param port: the port of the webserver. Defaults to ``5000`` or the
 |          port defined in the ``SERVER_NAME`` config variable if present.
 |      :param debug: if given, enable or disable debug mode. See
 |          :attr:`debug`.
 |      :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
 |          files to set environment variables. Will also change the working
 |          directory to the directory containing the first file found.
 |      :param options: the options to be forwarded to the underlying Werkzeug
 |          server. See :func:`werkzeug.serving.run_simple` for more
 |          information.
 |      
 |      .. versionchanged:: 1.0
 |          If installed, python-dotenv will be used to load environment
 |          variables from :file:`.env` and :file:`.flaskenv` files.
 |      
 |          The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.
 |      
 |          Threaded mode is enabled by default.
 |      
 |      .. versionchanged:: 0.10
 |          The default port is now picked from the ``SERVER_NAME``
 |          variable.
 |  
 |  select_jinja_autoescape(self, filename: 'str') -> 'bool'
 |      Returns ``True`` if autoescaping should be active for the given
 |      template name. If no template name is given, returns `True`.
 |      
 |      .. versionchanged:: 2.2
 |          Autoescaping is now enabled by default for ``.svg`` files.
 |      
 |      .. versionadded:: 0.5
 |  
 |  shell_context_processor(self, f: 'T_shell_context_processor') -> 'T_shell_context_processor'
 |      Registers a shell context processor function.
 |      
 |      .. versionadded:: 0.11
 |  
 |  should_ignore_error(self, error: 'BaseException | None') -> 'bool'
 |      This is called to figure out if an error should be ignored
 |      or not as far as the teardown system is concerned.  If this
 |      function returns ``True`` then the teardown handlers will not be
 |      passed the error.
 |      
 |      .. versionadded:: 0.10
 |  
 |  teardown_appcontext(self, f: 'T_teardown') -> 'T_teardown'
 |      Registers a function to be called when the application
 |      context is popped. The application context is typically popped
 |      after the request context for each request, at the end of CLI
 |      commands, or after a manually pushed context ends.
 |      
 |      .. code-block:: python
 |      
 |          with app.app_context():
 |              ...
 |      
 |      When the ``with`` block exits (or ``ctx.pop()`` is called), the
 |      teardown functions are called just before the app context is
 |      made inactive. Since a request context typically also manages an
 |      application context it would also be called when you pop a
 |      request context.
 |      
 |      When a teardown function was called because of an unhandled
 |      exception it will be passed an error object. If an
 |      :meth:`errorhandler` is registered, it will handle the exception
 |      and the teardown will not receive it.
 |      
 |      Teardown functions must avoid raising exceptions. If they
 |      execute code that might fail they must surround that code with a
 |      ``try``/``except`` block and log any errors.
 |      
 |      The return values of teardown functions are ignored.
 |      
 |      .. versionadded:: 0.9
 |  
 |  template_filter(self, name: 'str | None' = None) -> 't.Callable[[T_template_filter], T_template_filter]'
 |      A decorator that is used to register custom template filter.
 |      You can specify a name for the filter, otherwise the function
 |      name will be used. Example::
 |      
 |        @app.template_filter()
 |        def reverse(s):
 |            return s[::-1]
 |      
 |      :param name: the optional name of the filter, otherwise the
 |                   function name will be used.
 |  
 |  template_global(self, name: 'str | None' = None) -> 't.Callable[[T_template_global], T_template_global]'
 |      A decorator that is used to register a custom template global function.
 |      You can specify a name for the global function, otherwise the function
 |      name will be used. Example::
 |      
 |          @app.template_global()
 |          def double(n):
 |              return 2 * n
 |      
 |      .. versionadded:: 0.10
 |      
 |      :param name: the optional name of the global function, otherwise the
 |                   function name will be used.
 |  
 |  template_test(self, name: 'str | None' = None) -> 't.Callable[[T_template_test], T_template_test]'
 |      A decorator that is used to register custom template test.
 |      You can specify a name for the test, otherwise the function
 |      name will be used. Example::
 |      
 |        @app.template_test()
 |        def is_prime(n):
 |            if n == 2:
 |                return True
 |            for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
 |                if n % i == 0:
 |                    return False
 |            return True
 |      
 |      .. versionadded:: 0.10
 |      
 |      :param name: the optional name of the test, otherwise the
 |                   function name will be used.
 |  
 |  test_cli_runner(self, **kwargs: 't.Any') -> 'FlaskCliRunner'
 |      Create a CLI runner for testing CLI commands.
 |      See :ref:`testing-cli`.
 |      
 |      Returns an instance of :attr:`test_cli_runner_class`, by default
 |      :class:`~flask.testing.FlaskCliRunner`. The Flask app object is
 |      passed as the first argument.
 |      
 |      .. versionadded:: 1.0
 |  
 |  test_client(self, use_cookies: 'bool' = True, **kwargs: 't.Any') -> 'FlaskClient'
 |      Creates a test client for this application.  For information
 |      about unit testing head over to :doc:`/testing`.
 |      
 |      Note that if you are testing for assertions or exceptions in your
 |      application code, you must set ``app.testing = True`` in order for the
 |      exceptions to propagate to the test client.  Otherwise, the exception
 |      will be handled by the application (not visible to the test client) and
 |      the only indication of an AssertionError or other exception will be a
 |      500 status code response to the test client.  See the :attr:`testing`
 |      attribute.  For example::
 |      
 |          app.testing = True
 |          client = app.test_client()
 |      
 |      The test client can be used in a ``with`` block to defer the closing down
 |      of the context until the end of the ``with`` block.  This is useful if
 |      you want to access the context locals for testing::
 |      
 |          with app.test_client() as c:
 |              rv = c.get('/?vodka=42')
 |              assert request.args['vodka'] == '42'
 |      
 |      Additionally, you may pass optional keyword arguments that will then
 |      be passed to the application's :attr:`test_client_class` constructor.
 |      For example::
 |      
 |          from flask.testing import FlaskClient
 |      
 |          class CustomClient(FlaskClient):
 |              def __init__(self, *args, **kwargs):
 |                  self._authentication = kwargs.pop("authentication")
 |                  super(CustomClient,self).__init__( *args, **kwargs)
 |      
 |          app.test_client_class = CustomClient
 |          client = app.test_client(authentication='Basic ....')
 |      
 |      See :class:`~flask.testing.FlaskClient` for more information.
 |      
 |      .. versionchanged:: 0.4
 |         added support for ``with`` block usage for the client.
 |      
 |      .. versionadded:: 0.7
 |         The `use_cookies` parameter was added as well as the ability
 |         to override the client to be used by setting the
 |         :attr:`test_client_class` attribute.
 |      
 |      .. versionchanged:: 0.11
 |         Added `**kwargs` to support passing additional keyword arguments to
 |         the constructor of :attr:`test_client_class`.
 |  
 |  test_request_context(self, *args: 't.Any', **kwargs: 't.Any') -> 'RequestContext'
 |      Create a :class:`~flask.ctx.RequestContext` for a WSGI
 |      environment created from the given values. This is mostly useful
 |      during testing, where you may want to run a function that uses
 |      request data without dispatching a full request.
 |      
 |      See :doc:`/reqcontext`.
 |      
 |      Use a ``with`` block to push the context, which will make
 |      :data:`request` point at the request for the created
 |      environment. ::
 |      
 |          with app.test_request_context(...):
 |              generate_report()
 |      
 |      When using the shell, it may be easier to push and pop the
 |      context manually to avoid indentation. ::
 |      
 |          ctx = app.test_request_context(...)
 |          ctx.push()
 |          ...
 |          ctx.pop()
 |      
 |      Takes the same arguments as Werkzeug's
 |      :class:`~werkzeug.test.EnvironBuilder`, with some defaults from
 |      the application. See the linked Werkzeug docs for most of the
 |      available arguments. Flask-specific behavior is listed here.
 |      
 |      :param path: URL path being requested.
 |      :param base_url: Base URL where the app is being served, which
 |          ``path`` is relative to. If not given, built from
 |          :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
 |          :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
 |      :param subdomain: Subdomain name to append to
 |          :data:`SERVER_NAME`.
 |      :param url_scheme: Scheme to use instead of
 |          :data:`PREFERRED_URL_SCHEME`.
 |      :param data: The request body, either as a string or a dict of
 |          form keys and values.
 |      :param json: If given, this is serialized as JSON and passed as
 |          ``data``. Also defaults ``content_type`` to
 |          ``application/json``.
 |      :param args: other positional arguments passed to
 |          :class:`~werkzeug.test.EnvironBuilder`.
 |      :param kwargs: other keyword arguments passed to
 |          :class:`~werkzeug.test.EnvironBuilder`.
 |  
 |  trap_http_exception(self, e: 'Exception') -> 'bool'
 |      Checks if an HTTP exception should be trapped or not.  By default
 |      this will return ``False`` for all exceptions except for a bad request
 |      key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
 |      also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.
 |      
 |      This is called for all HTTP exceptions raised by a view function.
 |      If it returns ``True`` for any exception the error handler for this
 |      exception is not called and it shows up as regular exception in the
 |      traceback.  This is helpful for debugging implicitly raised HTTP
 |      exceptions.
 |      
 |      .. versionchanged:: 1.0
 |          Bad request errors are not trapped by default in debug mode.
 |      
 |      .. versionadded:: 0.8
 |  
 |  update_template_context(self, context: 'dict') -> 'None'
 |      Update the template context with some commonly used variables.
 |      This injects request, session, config and g into the template
 |      context as well as everything template context processors want
 |      to inject.  Note that the as of Flask 0.6, the original values
 |      in the context will not be overridden if a context processor
 |      decides to return a value with the same key.
 |      
 |      :param context: the context as a dictionary that is updated in place
 |                      to add extra variables.
 |  
 |  url_for(self, endpoint: 'str', *, _anchor: 'str | None' = None, _method: 'str | None' = None, _scheme: 'str | None' = None, _external: 'bool | None' = None, **values: 't.Any') -> 'str'
 |      Generate a URL to the given endpoint with the given values.
 |      
 |      This is called by :func:`flask.url_for`, and can be called
 |      directly as well.
 |      
 |      An *endpoint* is the name of a URL rule, usually added with
 |      :meth:`@app.route() <route>`, and usually the same name as the
 |      view function. A route defined in a :class:`~flask.Blueprint`
 |      will prepend the blueprint's name separated by a ``.`` to the
 |      endpoint.
 |      
 |      In some cases, such as email messages, you want URLs to include
 |      the scheme and domain, like ``https://example.com/hello``. When
 |      not in an active request, URLs will be external by default, but
 |      this requires setting :data:`SERVER_NAME` so Flask knows what
 |      domain to use. :data:`APPLICATION_ROOT` and
 |      :data:`PREFERRED_URL_SCHEME` should also be configured as
 |      needed. This config is only used when not in an active request.
 |      
 |      Functions can be decorated with :meth:`url_defaults` to modify
 |      keyword arguments before the URL is built.
 |      
 |      If building fails for some reason, such as an unknown endpoint
 |      or incorrect values, the app's :meth:`handle_url_build_error`
 |      method is called. If that returns a string, that is returned,
 |      otherwise a :exc:`~werkzeug.routing.BuildError` is raised.
 |      
 |      :param endpoint: The endpoint name associated with the URL to
 |          generate. If this starts with a ``.``, the current blueprint
 |          name (if any) will be used.
 |      :param _anchor: If given, append this as ``#anchor`` to the URL.
 |      :param _method: If given, generate the URL associated with this
 |          method for the endpoint.
 |      :param _scheme: If given, the URL will have this scheme if it
 |          is external.
 |      :param _external: If given, prefer the URL to be internal
 |          (False) or require it to be external (True). External URLs
 |          include the scheme and domain. When not in an active
 |          request, URLs are external by default.
 |      :param values: Values to use for the variable parts of the URL
 |          rule. Unknown keys are appended as query string arguments,
 |          like ``?a=b&c=d``.
 |      
 |      .. versionadded:: 2.2
 |          Moved from ``flask.url_for``, which calls this method.
 |  
 |  wsgi_app(self, environ: 'dict', start_response: 't.Callable') -> 't.Any'
 |      The actual WSGI application. This is not implemented in
 |      :meth:`__call__` so that middlewares can be applied without
 |      losing a reference to the app object. Instead of doing this::
 |      
 |          app = MyMiddleware(app)
 |      
 |      It's a better idea to do this instead::
 |      
 |          app.wsgi_app = MyMiddleware(app.wsgi_app)
 |      
 |      Then you still have the original application object around and
 |      can continue to call methods on it.
 |      
 |      .. versionchanged:: 0.7
 |          Teardown events for the request and app contexts are called
 |          even if an unhandled error occurs. Other events may not be
 |          called depending on when an error occurs during dispatch.
 |          See :ref:`callbacks-and-errors`.
 |      
 |      :param environ: A WSGI environment.
 |      :param start_response: A callable accepting a status code,
 |          a list of headers, and an optional exception context to
 |          start the response.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties defined here:
 |  
 |  got_first_request
 |      This attribute is set to ``True`` if the application started
 |      handling the first request.
 |      
 |      .. deprecated:: 2.3
 |          Will be removed in Flask 2.4.
 |      
 |      .. versionadded:: 0.8
 |  
 |  jinja_env
 |      The Jinja environment used to load templates.
 |      
 |      The environment is created the first time this property is
 |      accessed. Changing :attr:`jinja_options` after that will have no
 |      effect.
 |  
 |  logger
 |      A standard Python :class:`~logging.Logger` for the app, with
 |      the same name as :attr:`name`.
 |      
 |      In debug mode, the logger's :attr:`~logging.Logger.level` will
 |      be set to :data:`~logging.DEBUG`.
 |      
 |      If there are no handlers configured, a default handler will be
 |      added. See :doc:`/logging` for more information.
 |      
 |      .. versionchanged:: 1.1.0
 |          The logger takes the same name as :attr:`name` rather than
 |          hard-coding ``"flask.app"``.
 |      
 |      .. versionchanged:: 1.0.0
 |          Behavior was simplified. The logger is always named
 |          ``"flask.app"``. The level is only set during configuration,
 |          it doesn't check ``app.debug`` each time. Only one format is
 |          used, not different ones depending on ``app.debug``. No
 |          handlers are removed, and a handler is only added if no
 |          handlers are already configured.
 |      
 |      .. versionadded:: 0.3
 |  
 |  name
 |      The name of the application.  This is usually the import name
 |      with the difference that it's guessed from the run file if the
 |      import name is main.  This name is used as a display name when
 |      Flask needs the name of the application.  It can be set and overridden
 |      to change the value.
 |      
 |      .. versionadded:: 0.8
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  debug
 |      Whether debug mode is enabled. When using ``flask run`` to start the
 |      development server, an interactive debugger will be shown for unhandled
 |      exceptions, and the server will be reloaded when code changes. This maps to the
 |      :data:`DEBUG` config key. It may not behave as expected if set late.
 |      
 |      **Do not enable debug mode when deploying in production.**
 |      
 |      Default: ``False``
 |  
 |  permanent_session_lifetime
 |  
 |  secret_key
 |  
 |  testing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __annotations__ = {'jinja_options': 'dict', 'json_provider_class': 'ty...
 |  
 |  aborter_class = <class 'werkzeug.exceptions.Aborter'>
 |      When passed a dict of code -> exception items it can be used as
 |      callable that raises exceptions.  If the first argument to the
 |      callable is an integer it will be looked up in the mapping, if it's
 |      a WSGI application it will be raised in a proxy exception.
 |      
 |      The rest of the arguments are forwarded to the exception constructor.
 |  
 |  
 |  app_ctx_globals_class = <class 'flask.ctx._AppCtxGlobals'>
 |      A plain object. Used as a namespace for storing data during an
 |      application context.
 |      
 |      Creating an app context automatically creates this object, which is
 |      made available as the :data:`g` proxy.
 |      
 |      .. describe:: 'key' in g
 |      
 |          Check whether an attribute is present.
 |      
 |          .. versionadded:: 0.10
 |      
 |      .. describe:: iter(g)
 |      
 |          Return an iterator over the attribute names.
 |      
 |          .. versionadded:: 0.10
 |  
 |  
 |  config_class = <class 'flask.config.Config'>
 |      Works exactly like a dict but provides ways to fill it from files
 |      or special dictionaries.  There are two common patterns to populate the
 |      config.
 |      
 |      Either you can fill the config from a config file::
 |      
 |          app.config.from_pyfile('yourconfig.cfg')
 |      
 |      Or alternatively you can define the configuration options in the
 |      module that calls :meth:`from_object` or provide an import path to
 |      a module that should be loaded.  It is also possible to tell it to
 |      use the same module and with that provide the configuration values
 |      just before the call::
 |      
 |          DEBUG = True
 |          SECRET_KEY = 'development key'
 |          app.config.from_object(__name__)
 |      
 |      In both cases (loading from any Python file or loading from modules),
 |      only uppercase keys are added to the config.  This makes it possible to use
 |      lowercase values in the config file for temporary values that are not added
 |      to the config or to define the config keys in the same file that implements
 |      the application.
 |      
 |      Probably the most interesting way to load configurations is from an
 |      environment variable pointing to a file::
 |      
 |          app.config.from_envvar('YOURAPPLICATION_SETTINGS')
 |      
 |      In this case before launching the application you have to set this
 |      environment variable to the file you want to use.  On Linux and OS X
 |      use the export statement::
 |      
 |          export YOURAPPLICATION_SETTINGS='/path/to/config/file'
 |      
 |      On windows use `set` instead.
 |      
 |      :param root_path: path to which files are read relative from.  When the
 |                        config object is created by the application, this is
 |                        the application's :attr:`~flask.Flask.root_path`.
 |      :param defaults: an optional dictionary of default values
 |  
 |  
 |  default_config = ImmutableDict({'DEBUG': None, 'TESTING': False, ...TE...
 |  
 |  jinja_environment = <class 'flask.templating.Environment'>
 |      Works like a regular Jinja2 environment but has some additional
 |      knowledge of how Flask's blueprint works so that it can prepend the
 |      name of the blueprint to referenced templates if necessary.
 |  
 |  
 |  jinja_options = {}
 |  
 |  json_provider_class = <class 'flask.json.provider.DefaultJSONProvider'...
 |      Provide JSON operations using Python's built-in :mod:`json`
 |      library. Serializes the following additional data types:
 |      
 |      -   :class:`datetime.datetime` and :class:`datetime.date` are
 |          serialized to :rfc:`822` strings. This is the same as the HTTP
 |          date format.
 |      -   :class:`uuid.UUID` is serialized to a string.
 |      -   :class:`dataclasses.dataclass` is passed to
 |          :func:`dataclasses.asdict`.
 |      -   :class:`~markupsafe.Markup` (or any object with a ``__html__``
 |          method) will call the ``__html__`` method to get a string.
 |  
 |  
 |  request_class = <class 'flask.wrappers.Request'>
 |      The request object used by default in Flask.  Remembers the
 |      matched endpoint and view arguments.
 |      
 |      It is what ends up as :class:`~flask.request`.  If you want to replace
 |      the request object used you can subclass this and set
 |      :attr:`~flask.Flask.request_class` to your subclass.
 |      
 |      The request object is a :class:`~werkzeug.wrappers.Request` subclass and
 |      provides all of the attributes Werkzeug defines plus a few Flask
 |      specific ones.
 |  
 |  
 |  response_class = <class 'flask.wrappers.Response'>
 |      The response object that is used by default in Flask.  Works like the
 |      response object from Werkzeug but is set to have an HTML mimetype by
 |      default.  Quite often you don't have to create this object yourself because
 |      :meth:`~flask.Flask.make_response` will take care of that for you.
 |      
 |      If you want to replace the response object used you can subclass this and
 |      set :attr:`~flask.Flask.response_class` to your subclass.
 |      
 |      .. versionchanged:: 1.0
 |          JSON support is added to the response, like the request. This is useful
 |          when testing to get the test client response data as JSON.
 |      
 |      .. versionchanged:: 1.0
 |      
 |          Added :attr:`max_cookie_size`.
 |  
 |  
 |  session_interface = <flask.sessions.SecureCookieSessionInterface objec...
 |  
 |  test_cli_runner_class = None
 |  
 |  test_client_class = None
 |  
 |  url_map_class = <class 'werkzeug.routing.map.Map'>
 |      The map class stores all the URL rules and some configuration
 |      parameters.  Some of the configuration values are only stored on the
 |      `Map` instance since those affect all rules, others are just defaults
 |      and can be overridden for each rule.  Note that you have to specify all
 |      arguments besides the `rules` as keyword arguments!
 |      
 |      :param rules: sequence of url rules for this map.
 |      :param default_subdomain: The default subdomain for rules without a
 |                                subdomain defined.
 |      :param charset: charset of the url. defaults to ``"utf-8"``
 |      :param strict_slashes: If a rule ends with a slash but the matched
 |          URL does not, redirect to the URL with a trailing slash.
 |      :param merge_slashes: Merge consecutive slashes when matching or
 |          building URLs. Matches will redirect to the normalized URL.
 |          Slashes in variable parts are not merged.
 |      :param redirect_defaults: This will redirect to the default rule if it
 |                                wasn't visited that way. This helps creating
 |                                unique URLs.
 |      :param converters: A dict of converters that adds additional converters
 |                         to the list of converters. If you redefine one
 |                         converter this will override the original one.
 |      :param sort_parameters: If set to `True` the url parameters are sorted.
 |                              See `url_encode` for more details.
 |      :param sort_key: The sort key function for `url_encode`.
 |      :param encoding_errors: the error method to use for decoding
 |      :param host_matching: if set to `True` it enables the host matching
 |                            feature and disables the subdomain one.  If
 |                            enabled the `host` parameter to rules is used
 |                            instead of the `subdomain` one.
 |      
 |      .. versionchanged:: 2.3
 |          The ``charset`` and ``encoding_errors`` parameters are deprecated and will be
 |          removed in Werkzeug 3.0.
 |      
 |      .. versionchanged:: 1.0
 |          If ``url_scheme`` is ``ws`` or ``wss``, only WebSocket rules will match.
 |      
 |      .. versionchanged:: 1.0
 |          The ``merge_slashes`` parameter was added.
 |      
 |      .. versionchanged:: 0.7
 |          The ``encoding_errors`` and ``host_matching`` parameters were added.
 |      
 |      .. versionchanged:: 0.5
 |          The ``sort_parameters`` and ``sort_key``  paramters were added.
 |  
 |  
 |  url_rule_class = <class 'werkzeug.routing.rules.Rule'>
 |      A Rule represents one URL pattern.  There are some options for `Rule`
 |      that change the way it behaves and are passed to the `Rule` constructor.
 |      Note that besides the rule-string all arguments *must* be keyword arguments
 |      in order to not break the application on Werkzeug upgrades.
 |      
 |      `string`
 |          Rule strings basically are just normal URL paths with placeholders in
 |          the format ``<converter(arguments):name>`` where the converter and the
 |          arguments are optional.  If no converter is defined the `default`
 |          converter is used which means `string` in the normal configuration.
 |      
 |          URL rules that end with a slash are branch URLs, others are leaves.
 |          If you have `strict_slashes` enabled (which is the default), all
 |          branch URLs that are matched without a trailing slash will trigger a
 |          redirect to the same URL with the missing slash appended.
 |      
 |          The converters are defined on the `Map`.
 |      
 |      `endpoint`
 |          The endpoint for this rule. This can be anything. A reference to a
 |          function, a string, a number etc.  The preferred way is using a string
 |          because the endpoint is used for URL generation.
 |      
 |      `defaults`
 |          An optional dict with defaults for other rules with the same endpoint.
 |          This is a bit tricky but useful if you want to have unique URLs::
 |      
 |              url_map = Map([
 |                  Rule('/all/', defaults={'page': 1}, endpoint='all_entries'),
 |                  Rule('/all/page/<int:page>', endpoint='all_entries')
 |              ])
 |      
 |          If a user now visits ``http://example.com/all/page/1`` they will be
 |          redirected to ``http://example.com/all/``.  If `redirect_defaults` is
 |          disabled on the `Map` instance this will only affect the URL
 |          generation.
 |      
 |      `subdomain`
 |          The subdomain rule string for this rule. If not specified the rule
 |          only matches for the `default_subdomain` of the map.  If the map is
 |          not bound to a subdomain this feature is disabled.
 |      
 |          Can be useful if you want to have user profiles on different subdomains
 |          and all subdomains are forwarded to your application::
 |      
 |              url_map = Map([
 |                  Rule('/', subdomain='<username>', endpoint='user/homepage'),
 |                  Rule('/stats', subdomain='<username>', endpoint='user/stats')
 |              ])
 |      
 |      `methods`
 |          A sequence of http methods this rule applies to.  If not specified, all
 |          methods are allowed. For example this can be useful if you want different
 |          endpoints for `POST` and `GET`.  If methods are defined and the path
 |          matches but the method matched against is not in this list or in the
 |          list of another rule for that path the error raised is of the type
 |          `MethodNotAllowed` rather than `NotFound`.  If `GET` is present in the
 |          list of methods and `HEAD` is not, `HEAD` is added automatically.
 |      
 |      `strict_slashes`
 |          Override the `Map` setting for `strict_slashes` only for this rule. If
 |          not specified the `Map` setting is used.
 |      
 |      `merge_slashes`
 |          Override :attr:`Map.merge_slashes` for this rule.
 |      
 |      `build_only`
 |          Set this to True and the rule will never match but will create a URL
 |          that can be build. This is useful if you have resources on a subdomain
 |          or folder that are not handled by the WSGI application (like static data)
 |      
 |      `redirect_to`
 |          If given this must be either a string or callable.  In case of a
 |          callable it's called with the url adapter that triggered the match and
 |          the values of the URL as keyword arguments and has to return the target
 |          for the redirect, otherwise it has to be a string with placeholders in
 |          rule syntax::
 |      
 |              def foo_with_slug(adapter, id):
 |                  # ask the database for the slug for the old id.  this of
 |                  # course has nothing to do with werkzeug.
 |                  return f'foo/{Foo.get_slug_for_id(id)}'
 |      
 |              url_map = Map([
 |                  Rule('/foo/<slug>', endpoint='foo'),
 |                  Rule('/some/old/url/<slug>', redirect_to='foo/<slug>'),
 |                  Rule('/other/old/url/<int:id>', redirect_to=foo_with_slug)
 |              ])
 |      
 |          When the rule is matched the routing system will raise a
 |          `RequestRedirect` exception with the target for the redirect.
 |      
 |          Keep in mind that the URL will be joined against the URL root of the
 |          script so don't use a leading slash on the target URL unless you
 |          really mean root of that domain.
 |      
 |      `alias`
 |          If enabled this rule serves as an alias for another rule with the same
 |          endpoint and arguments.
 |      
 |      `host`
 |          If provided and the URL map has host matching enabled this can be
 |          used to provide a match rule for the whole host.  This also means
 |          that the subdomain feature is disabled.
 |      
 |      `websocket`
 |          If ``True``, this rule is only matches for WebSocket (``ws://``,
 |          ``wss://``) requests. By default, rules will only match for HTTP
 |          requests.
 |      
 |      .. versionchanged:: 2.1
 |          Percent-encoded newlines (``%0a``), which are decoded by WSGI
 |          servers, are considered when routing instead of terminating the
 |          match early.
 |      
 |      .. versionadded:: 1.0
 |          Added ``websocket``.
 |      
 |      .. versionadded:: 1.0
 |          Added ``merge_slashes``.
 |      
 |      .. versionadded:: 0.7
 |          Added ``alias`` and ``host``.
 |      
 |      .. versionchanged:: 0.6.1
 |         ``HEAD`` is added to ``methods`` if ``GET`` is present.
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from flask.scaffold.Scaffold:
 |  
 |  __repr__(self) -> 'str'
 |      Return repr(self).
 |  
 |  after_request(self, f: 'T_after_request') -> 'T_after_request'
 |      Register a function to run after each request to this object.
 |      
 |      The function is called with the response object, and must return
 |      a response object. This allows the functions to modify or
 |      replace the response before it is sent.
 |      
 |      If a function raises an exception, any remaining
 |      ``after_request`` functions will not be called. Therefore, this
 |      should not be used for actions that must execute, such as to
 |      close resources. Use :meth:`teardown_request` for that.
 |      
 |      This is available on both app and blueprint objects. When used on an app, this
 |      executes after every request. When used on a blueprint, this executes after
 |      every request that the blueprint handles. To register with a blueprint and
 |      execute after every request, use :meth:`.Blueprint.after_app_request`.
 |  
 |  before_request(self, f: 'T_before_request') -> 'T_before_request'
 |      Register a function to run before each request.
 |      
 |      For example, this can be used to open a database connection, or
 |      to load the logged in user from the session.
 |      
 |      .. code-block:: python
 |      
 |          @app.before_request
 |          def load_user():
 |              if "user_id" in session:
 |                  g.user = db.session.get(session["user_id"])
 |      
 |      The function will be called without any arguments. If it returns
 |      a non-``None`` value, the value is handled as if it was the
 |      return value from the view, and further request handling is
 |      stopped.
 |      
 |      This is available on both app and blueprint objects. When used on an app, this
 |      executes before every request. When used on a blueprint, this executes before
 |      every request that the blueprint handles. To register with a blueprint and
 |      execute before every request, use :meth:`.Blueprint.before_app_request`.
 |  
 |  context_processor(self, f: 'T_template_context_processor') -> 'T_template_context_processor'
 |      Registers a template context processor function. These functions run before
 |      rendering a template. The keys of the returned dict are added as variables
 |      available in the template.
 |      
 |      This is available on both app and blueprint objects. When used on an app, this
 |      is called for every rendered template. When used on a blueprint, this is called
 |      for templates rendered from the blueprint's views. To register with a blueprint
 |      and affect every template, use :meth:`.Blueprint.app_context_processor`.
 |  
 |  delete(self, rule: 'str', **options: 't.Any') -> 't.Callable[[T_route], T_route]'
 |      Shortcut for :meth:`route` with ``methods=["DELETE"]``.
 |      
 |      .. versionadded:: 2.0
 |  
 |  endpoint(self, endpoint: 'str') -> 't.Callable[[F], F]'
 |      Decorate a view function to register it for the given
 |      endpoint. Used if a rule is added without a ``view_func`` with
 |      :meth:`add_url_rule`.
 |      
 |      .. code-block:: python
 |      
 |          app.add_url_rule("/ex", endpoint="example")
 |      
 |          @app.endpoint("example")
 |          def example():
 |              ...
 |      
 |      :param endpoint: The endpoint name to associate with the view
 |          function.
 |  
 |  errorhandler(self, code_or_exception: 'type[Exception] | int') -> 't.Callable[[T_error_handler], T_error_handler]'
 |      Register a function to handle errors by code or exception class.
 |      
 |      A decorator that is used to register a function given an
 |      error code.  Example::
 |      
 |          @app.errorhandler(404)
 |          def page_not_found(error):
 |              return 'This page does not exist', 404
 |      
 |      You can also register handlers for arbitrary exceptions::
 |      
 |          @app.errorhandler(DatabaseError)
 |          def special_exception_handler(error):
 |              return 'Database connection failed', 500
 |      
 |      This is available on both app and blueprint objects. When used on an app, this
 |      can handle errors from every request. When used on a blueprint, this can handle
 |      errors from requests that the blueprint handles. To register with a blueprint
 |      and affect every request, use :meth:`.Blueprint.app_errorhandler`.
 |      
 |      .. versionadded:: 0.7
 |          Use :meth:`register_error_handler` instead of modifying
 |          :attr:`error_handler_spec` directly, for application wide error
 |          handlers.
 |      
 |      .. versionadded:: 0.7
 |         One can now additionally also register custom exception types
 |         that do not necessarily have to be a subclass of the
 |         :class:`~werkzeug.exceptions.HTTPException` class.
 |      
 |      :param code_or_exception: the code as integer for the handler, or
 |                                an arbitrary exception
 |  
 |  get(self, rule: 'str', **options: 't.Any') -> 't.Callable[[T_route], T_route]'
 |      Shortcut for :meth:`route` with ``methods=["GET"]``.
 |      
 |      .. versionadded:: 2.0
 |  
 |  get_send_file_max_age(self, filename: 'str | None') -> 'int | None'
 |      Used by :func:`send_file` to determine the ``max_age`` cache
 |      value for a given file path if it wasn't passed.
 |      
 |      By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
 |      the configuration of :data:`~flask.current_app`. This defaults
 |      to ``None``, which tells the browser to use conditional requests
 |      instead of a timed cache, which is usually preferable.
 |      
 |      .. versionchanged:: 2.0
 |          The default configuration is ``None`` instead of 12 hours.
 |      
 |      .. versionadded:: 0.9
 |  
 |  open_resource(self, resource: 'str', mode: 'str' = 'rb') -> 't.IO[t.AnyStr]'
 |      Open a resource file relative to :attr:`root_path` for
 |      reading.
 |      
 |      For example, if the file ``schema.sql`` is next to the file
 |      ``app.py`` where the ``Flask`` app is defined, it can be opened
 |      with:
 |      
 |      .. code-block:: python
 |      
 |          with app.open_resource("schema.sql") as f:
 |              conn.executescript(f.read())
 |      
 |      :param resource: Path to the resource relative to
 |          :attr:`root_path`.
 |      :param mode: Open the file in this mode. Only reading is
 |          supported, valid values are "r" (or "rt") and "rb".
 |  
 |  patch(self, rule: 'str', **options: 't.Any') -> 't.Callable[[T_route], T_route]'
 |      Shortcut for :meth:`route` with ``methods=["PATCH"]``.
 |      
 |      .. versionadded:: 2.0
 |  
 |  post(self, rule: 'str', **options: 't.Any') -> 't.Callable[[T_route], T_route]'
 |      Shortcut for :meth:`route` with ``methods=["POST"]``.
 |      
 |      .. versionadded:: 2.0
 |  
 |  put(self, rule: 'str', **options: 't.Any') -> 't.Callable[[T_route], T_route]'
 |      Shortcut for :meth:`route` with ``methods=["PUT"]``.
 |      
 |      .. versionadded:: 2.0
 |  
 |  register_error_handler(self, code_or_exception: 'type[Exception] | int', f: 'ft.ErrorHandlerCallable') -> 'None'
 |      Alternative error attach function to the :meth:`errorhandler`
 |      decorator that is more straightforward to use for non decorator
 |      usage.
 |      
 |      .. versionadded:: 0.7
 |  
 |  route(self, rule: 'str', **options: 't.Any') -> 't.Callable[[T_route], T_route]'
 |      Decorate a view function to register it with the given URL
 |      rule and options. Calls :meth:`add_url_rule`, which has more
 |      details about the implementation.
 |      
 |      .. code-block:: python
 |      
 |          @app.route("/")
 |          def index():
 |              return "Hello, World!"
 |      
 |      See :ref:`url-route-registrations`.
 |      
 |      The endpoint name for the route defaults to the name of the view
 |      function if the ``endpoint`` parameter isn't passed.
 |      
 |      The ``methods`` parameter defaults to ``["GET"]``. ``HEAD`` and
 |      ``OPTIONS`` are added automatically.
 |      
 |      :param rule: The URL rule string.
 |      :param options: Extra options passed to the
 |          :class:`~werkzeug.routing.Rule` object.
 |  
 |  send_static_file(self, filename: 'str') -> 'Response'
 |      The view function used to serve files from
 |      :attr:`static_folder`. A route is automatically registered for
 |      this view at :attr:`static_url_path` if :attr:`static_folder` is
 |      set.
 |      
 |      .. versionadded:: 0.5
 |  
 |  teardown_request(self, f: 'T_teardown') -> 'T_teardown'
 |      Register a function to be called when the request context is
 |      popped. Typically this happens at the end of each request, but
 |      contexts may be pushed manually as well during testing.
 |      
 |      .. code-block:: python
 |      
 |          with app.test_request_context():
 |              ...
 |      
 |      When the ``with`` block exits (or ``ctx.pop()`` is called), the
 |      teardown functions are called just before the request context is
 |      made inactive.
 |      
 |      When a teardown function was called because of an unhandled
 |      exception it will be passed an error object. If an
 |      :meth:`errorhandler` is registered, it will handle the exception
 |      and the teardown will not receive it.
 |      
 |      Teardown functions must avoid raising exceptions. If they
 |      execute code that might fail they must surround that code with a
 |      ``try``/``except`` block and log any errors.
 |      
 |      The return values of teardown functions are ignored.
 |      
 |      This is available on both app and blueprint objects. When used on an app, this
 |      executes after every request. When used on a blueprint, this executes after
 |      every request that the blueprint handles. To register with a blueprint and
 |      execute after every request, use :meth:`.Blueprint.teardown_app_request`.
 |  
 |  url_defaults(self, f: 'T_url_defaults') -> 'T_url_defaults'
 |      Callback function for URL defaults for all view functions of the
 |      application.  It's called with the endpoint and values and should
 |      update the values passed in place.
 |      
 |      This is available on both app and blueprint objects. When used on an app, this
 |      is called for every request. When used on a blueprint, this is called for
 |      requests that the blueprint handles. To register with a blueprint and affect
 |      every request, use :meth:`.Blueprint.app_url_defaults`.
 |  
 |  url_value_preprocessor(self, f: 'T_url_value_preprocessor') -> 'T_url_value_preprocessor'
 |      Register a URL value preprocessor function for all view
 |      functions in the application. These functions will be called before the
 |      :meth:`before_request` functions.
 |      
 |      The function can modify the values captured from the matched url before
 |      they are passed to the view. For example, this can be used to pop a
 |      common language code value and place it in ``g`` rather than pass it to
 |      every view.
 |      
 |      The function is passed the endpoint name and values dict. The return
 |      value is ignored.
 |      
 |      This is available on both app and blueprint objects. When used on an app, this
 |      is called for every request. When used on a blueprint, this is called for
 |      requests that the blueprint handles. To register with a blueprint and affect
 |      every request, use :meth:`.Blueprint.app_url_value_preprocessor`.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from flask.scaffold.Scaffold:
 |  
 |  has_static_folder
 |      ``True`` if :attr:`static_folder` is set.
 |      
 |      .. versionadded:: 0.5
 |  
 |  jinja_loader
 |      The Jinja loader for this object's templates. By default this
 |      is a class :class:`jinja2.loaders.FileSystemLoader` to
 |      :attr:`template_folder` if it is set.
 |      
 |      .. versionadded:: 0.5
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from flask.scaffold.Scaffold:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  static_folder
 |      The absolute path to the configured static folder. ``None``
 |      if no static folder is set.
 |  
 |  static_url_path
 |      The URL prefix that the static route will be accessible from.
 |      
 |      If it was not configured during init, it is derived from
 |      :attr:`static_folder`.

